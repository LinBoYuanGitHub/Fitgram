// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: login.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Apisvr_UserType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownUserType // = 0
  case registered // = 1
  case vip // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownUserType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownUserType
    case 1: self = .registered
    case 2: self = .vip
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownUserType: return 0
    case .registered: return 1
    case .vip: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Apisvr_UserType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Apisvr_UserType] = [
    .unknownUserType,
    .registered,
    .vip,
  ]
}

#endif  // swift(>=4.2)

enum Apisvr_OtpType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownOtpType // = 0
  case loginOtp // = 1
  case registerOtp // = 2
  case resetPassOtp // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownOtpType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownOtpType
    case 1: self = .loginOtp
    case 2: self = .registerOtp
    case 3: self = .resetPassOtp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownOtpType: return 0
    case .loginOtp: return 1
    case .registerOtp: return 2
    case .resetPassOtp: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Apisvr_OtpType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Apisvr_OtpType] = [
    .unknownOtpType,
    .loginOtp,
    .registerOtp,
    .resetPassOtp,
  ]
}

#endif  // swift(>=4.2)

struct Apisvr_AnonymousLoginReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pass empty string at first time
  var userID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_AnonymousLoginResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var userID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_AppLoginReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var phone: String = String()

  var password: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_AppLoginResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var isNewUser: Bool = false

  var userType: Apisvr_UserType = .unknownUserType

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_OneTimePasswordLoginReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var phone: String = String()

  var otp: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_OneTimePasswordLoginResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var isNewUser: Bool = false

  var userType: Apisvr_UserType = .unknownUserType

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_ThirdPartyLoginReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uid: String = String()

  var accessToken: String = String()

  var platform: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_ThirdPartyLoginResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var isNewUser: Bool = false

  var userType: Apisvr_UserType = .unknownUserType

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_VerifyPhoneNumReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var phone: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_VerifyPhoneNumResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isExist: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_RegisterWithPassReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var phone: String = String()

  var password: String = String()

  var otp: String = String()

  var userID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_RegisterWithPassResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_GetOneTimePasswordReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var phone: String = String()

  var purpose: Apisvr_OtpType = .unknownOtpType

  var userID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_GetOneTimePasswordResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var otp: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_VerifyOneTimePasswordReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var phone: String = String()

  var otp: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_VerifyOneTimePasswordResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var otpToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_ResetPasswordReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var otpToken: String = String()

  var password: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_ResetPasswordResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "apisvr"

extension Apisvr_UserType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_USER_TYPE"),
    1: .same(proto: "REGISTERED"),
    2: .same(proto: "VIP"),
  ]
}

extension Apisvr_OtpType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_OTP_TYPE"),
    1: .same(proto: "LOGIN_OTP"),
    2: .same(proto: "REGISTER_OTP"),
    3: .same(proto: "RESET_PASS_OTP"),
  ]
}

extension Apisvr_AnonymousLoginReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AnonymousLoginReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.userID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_AnonymousLoginReq, rhs: Apisvr_AnonymousLoginReq) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_AnonymousLoginResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AnonymousLoginResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      case 2: try decoder.decodeSingularStringField(value: &self.userID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_AnonymousLoginResp, rhs: Apisvr_AnonymousLoginResp) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_AppLoginReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppLoginReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.phone)
      case 2: try decoder.decodeSingularStringField(value: &self.password)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_AppLoginReq, rhs: Apisvr_AppLoginReq) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_AppLoginResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppLoginResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .standard(proto: "is_new_user"),
    3: .standard(proto: "user_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      case 2: try decoder.decodeSingularBoolField(value: &self.isNewUser)
      case 3: try decoder.decodeSingularEnumField(value: &self.userType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if self.isNewUser != false {
      try visitor.visitSingularBoolField(value: self.isNewUser, fieldNumber: 2)
    }
    if self.userType != .unknownUserType {
      try visitor.visitSingularEnumField(value: self.userType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_AppLoginResp, rhs: Apisvr_AppLoginResp) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.isNewUser != rhs.isNewUser {return false}
    if lhs.userType != rhs.userType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_OneTimePasswordLoginReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OneTimePasswordLoginReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "otp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.phone)
      case 2: try decoder.decodeSingularStringField(value: &self.otp)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if !self.otp.isEmpty {
      try visitor.visitSingularStringField(value: self.otp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_OneTimePasswordLoginReq, rhs: Apisvr_OneTimePasswordLoginReq) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.otp != rhs.otp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_OneTimePasswordLoginResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OneTimePasswordLoginResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .standard(proto: "is_new_user"),
    3: .standard(proto: "user_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      case 2: try decoder.decodeSingularBoolField(value: &self.isNewUser)
      case 3: try decoder.decodeSingularEnumField(value: &self.userType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if self.isNewUser != false {
      try visitor.visitSingularBoolField(value: self.isNewUser, fieldNumber: 2)
    }
    if self.userType != .unknownUserType {
      try visitor.visitSingularEnumField(value: self.userType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_OneTimePasswordLoginResp, rhs: Apisvr_OneTimePasswordLoginResp) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.isNewUser != rhs.isNewUser {return false}
    if lhs.userType != rhs.userType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_ThirdPartyLoginReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThirdPartyLoginReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .standard(proto: "access_token"),
    3: .same(proto: "platform"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.uid)
      case 2: try decoder.decodeSingularStringField(value: &self.accessToken)
      case 3: try decoder.decodeSingularInt32Field(value: &self.platform)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if !self.accessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.accessToken, fieldNumber: 2)
    }
    if self.platform != 0 {
      try visitor.visitSingularInt32Field(value: self.platform, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_ThirdPartyLoginReq, rhs: Apisvr_ThirdPartyLoginReq) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.accessToken != rhs.accessToken {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_ThirdPartyLoginResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThirdPartyLoginResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .standard(proto: "is_new_user"),
    3: .standard(proto: "user_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      case 2: try decoder.decodeSingularBoolField(value: &self.isNewUser)
      case 3: try decoder.decodeSingularEnumField(value: &self.userType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if self.isNewUser != false {
      try visitor.visitSingularBoolField(value: self.isNewUser, fieldNumber: 2)
    }
    if self.userType != .unknownUserType {
      try visitor.visitSingularEnumField(value: self.userType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_ThirdPartyLoginResp, rhs: Apisvr_ThirdPartyLoginResp) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.isNewUser != rhs.isNewUser {return false}
    if lhs.userType != rhs.userType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_VerifyPhoneNumReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyPhoneNumReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.phone)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_VerifyPhoneNumReq, rhs: Apisvr_VerifyPhoneNumReq) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_VerifyPhoneNumResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyPhoneNumResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_exist"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.isExist)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isExist != false {
      try visitor.visitSingularBoolField(value: self.isExist, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_VerifyPhoneNumResp, rhs: Apisvr_VerifyPhoneNumResp) -> Bool {
    if lhs.isExist != rhs.isExist {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_RegisterWithPassReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterWithPassReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "password"),
    3: .same(proto: "otp"),
    4: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.phone)
      case 2: try decoder.decodeSingularStringField(value: &self.password)
      case 3: try decoder.decodeSingularStringField(value: &self.otp)
      case 4: try decoder.decodeSingularStringField(value: &self.userID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.otp.isEmpty {
      try visitor.visitSingularStringField(value: self.otp, fieldNumber: 3)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_RegisterWithPassReq, rhs: Apisvr_RegisterWithPassReq) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.password != rhs.password {return false}
    if lhs.otp != rhs.otp {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_RegisterWithPassResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterWithPassResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_RegisterWithPassResp, rhs: Apisvr_RegisterWithPassResp) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_GetOneTimePasswordReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetOneTimePasswordReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "purpose"),
    3: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.phone)
      case 2: try decoder.decodeSingularEnumField(value: &self.purpose)
      case 3: try decoder.decodeSingularStringField(value: &self.userID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if self.purpose != .unknownOtpType {
      try visitor.visitSingularEnumField(value: self.purpose, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_GetOneTimePasswordReq, rhs: Apisvr_GetOneTimePasswordReq) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.purpose != rhs.purpose {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_GetOneTimePasswordResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetOneTimePasswordResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "otp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.otp)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.otp.isEmpty {
      try visitor.visitSingularStringField(value: self.otp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_GetOneTimePasswordResp, rhs: Apisvr_GetOneTimePasswordResp) -> Bool {
    if lhs.otp != rhs.otp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_VerifyOneTimePasswordReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyOneTimePasswordReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "otp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.phone)
      case 2: try decoder.decodeSingularStringField(value: &self.otp)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if !self.otp.isEmpty {
      try visitor.visitSingularStringField(value: self.otp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_VerifyOneTimePasswordReq, rhs: Apisvr_VerifyOneTimePasswordReq) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.otp != rhs.otp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_VerifyOneTimePasswordResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyOneTimePasswordResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "otp_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.otpToken)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.otpToken.isEmpty {
      try visitor.visitSingularStringField(value: self.otpToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_VerifyOneTimePasswordResp, rhs: Apisvr_VerifyOneTimePasswordResp) -> Bool {
    if lhs.otpToken != rhs.otpToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_ResetPasswordReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResetPasswordReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "otp_token"),
    2: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.otpToken)
      case 2: try decoder.decodeSingularStringField(value: &self.password)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.otpToken.isEmpty {
      try visitor.visitSingularStringField(value: self.otpToken, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_ResetPasswordReq, rhs: Apisvr_ResetPasswordReq) -> Bool {
    if lhs.otpToken != rhs.otpToken {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_ResetPasswordResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResetPasswordResp"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_ResetPasswordResp, rhs: Apisvr_ResetPasswordResp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
