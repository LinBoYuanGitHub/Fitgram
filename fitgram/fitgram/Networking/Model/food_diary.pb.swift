// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: food_diary.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Apisvr_InputType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownInputType // = 0
  case recommendation // = 1
  case camera // = 2
  case album // = 3
  case text // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownInputType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownInputType
    case 1: self = .recommendation
    case 2: self = .camera
    case 3: self = .album
    case 4: self = .text
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownInputType: return 0
    case .recommendation: return 1
    case .camera: return 2
    case .album: return 3
    case .text: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Apisvr_InputType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Apisvr_InputType] = [
    .unknownInputType,
    .recommendation,
    .camera,
    .album,
    .text,
  ]
}

#endif  // swift(>=4.2)

enum Apisvr_MealType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownMealType // = 0
  case breakfast // = 1
  case lunch // = 2
  case dinner // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownMealType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownMealType
    case 1: self = .breakfast
    case 2: self = .lunch
    case 3: self = .dinner
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownMealType: return 0
    case .breakfast: return 1
    case .lunch: return 2
    case .dinner: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Apisvr_MealType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Apisvr_MealType] = [
    .unknownMealType,
    .breakfast,
    .lunch,
    .dinner,
  ]
}

#endif  // swift(>=4.2)

enum Apisvr_Category: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownCategoryType // = 0
  case recipe // = 1
  case favorite // = 2
  case restaurant // = 3
  case ingredient // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownCategoryType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownCategoryType
    case 1: self = .recipe
    case 2: self = .favorite
    case 3: self = .restaurant
    case 4: self = .ingredient
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownCategoryType: return 0
    case .recipe: return 1
    case .favorite: return 2
    case .restaurant: return 3
    case .ingredient: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Apisvr_Category: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Apisvr_Category] = [
    .unknownCategoryType,
    .recipe,
    .favorite,
    .restaurant,
    .ingredient,
  ]
}

#endif  // swift(>=4.2)

struct Apisvr_Calendar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var year: Int32 = 0

  var months: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_GetMealLogCalendarReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var calendar: [Apisvr_Calendar] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_MealLogCalendarItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var date: Int64 = 0

  var imgURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_GetMealLogCalendarResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var calendarItems: [Apisvr_MealLogCalendarItem] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_GetFoodDiaryReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var date: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_FoodDiaryNutrient {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var energyIntake: Double = 0

  var fatIntake: Double = 0

  var proteinIntake: Double = 0

  var carbohydrateIntake: Double = 0

  var energyRecommend: Double = 0

  var fatRecommend: Double = 0

  var proteinRecommend: Double = 0

  var carbohydrateRecommend: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_NutrientByMeal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var breakfastEnergy: Double = 0

  var lunchEnergy: Double = 0

  var dinnerEnergy: Double = 0

  var breakfastPercentage: Double = 0

  var lunchPercentage: Double = 0

  var dinnerPercentage: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_FoodDiaryFoodLog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var foodID: Int32 = 0

  var foodName: String = String()

  var amount: Double = 0

  var unit: String = String()

  var energy: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_FoodDiaryMealLog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mealLogID: Int32 = 0

  var imgURL: String = String()

  var foodLog: [Apisvr_FoodDiaryFoodLog] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_MealLogByType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mealType: Apisvr_MealType = .unknownMealType

  var mealLogByType: [Apisvr_FoodDiaryMealLog] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_GetFoodDiaryResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nutrient: Apisvr_FoodDiaryNutrient {
    get {return _storage._nutrient ?? Apisvr_FoodDiaryNutrient()}
    set {_uniqueStorage()._nutrient = newValue}
  }
  /// Returns true if `nutrient` has been explicitly set.
  var hasNutrient: Bool {return _storage._nutrient != nil}
  /// Clears the value of `nutrient`. Subsequent reads from it will return its default value.
  mutating func clearNutrient() {_uniqueStorage()._nutrient = nil}

  var nutrientByMeal: Apisvr_NutrientByMeal {
    get {return _storage._nutrientByMeal ?? Apisvr_NutrientByMeal()}
    set {_uniqueStorage()._nutrientByMeal = newValue}
  }
  /// Returns true if `nutrientByMeal` has been explicitly set.
  var hasNutrientByMeal: Bool {return _storage._nutrientByMeal != nil}
  /// Clears the value of `nutrientByMeal`. Subsequent reads from it will return its default value.
  mutating func clearNutrientByMeal() {_uniqueStorage()._nutrientByMeal = nil}

  var mealLogs: [Apisvr_MealLogByType] {
    get {return _storage._mealLogs}
    set {_uniqueStorage()._mealLogs = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Apisvr_GetMealLogReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mealLogID: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_UnitOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unitID: Int32 = 0

  var name: String = String()

  var weight: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_FoodLog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var foodID: Int32 = 0

  var foodName: String = String()

  var energy: Double = 0

  var fat: Double = 0

  var protein: Double = 0

  var carbohydrate: Double = 0

  var amount: Double = 0

  var selectedUnitID: Int32 = 0

  var unitOption: [Apisvr_UnitOption] = []

  var ingredients: [Apisvr_Ingredient] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_GetMealLogResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imgURL: String = String()

  var foodLogs: [Apisvr_FoodLog] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_FoodTag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var foodID: Int32 = 0

  var tagX: Double = 0

  var tagY: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// bulk request
struct Apisvr_GetFoodLogDetailReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var foodTags: [Apisvr_FoodTag] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_GetFoodLogDetailResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var foodLogs: [Apisvr_FoodLog] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// convert food tag xy to food log info
struct Apisvr_FoodLogInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var foodID: Int32 = 0

  var amount: Double = 0

  var selectedUnitID: Int32 = 0

  var tagX: Double = 0

  var tagY: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_CreateMealLogReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imgURL: String = String()

  var date: Int64 = 0

  var inputType: Apisvr_InputType = .unknownInputType

  var mealType: Apisvr_MealType = .unknownMealType

  var foodLogs: [Apisvr_FoodLogInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_CreateMealLogResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// bulk foodlog update
struct Apisvr_UpdateMealLogReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mealLogID: Int32 = 0

  var foodLogs: [Apisvr_FoodLogInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_UpdateMealLogResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_DeleteMealLogReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mealLogID: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_DeleteMealLogResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_RecognitionReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imgURL: String = String()

  var mealDate: Int64 = 0

  var mealType: Apisvr_MealType = .unknownMealType

  var lat: Double = 0

  var lng: Double = 0

  var imgUploadSpeed: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_RecognitionResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var taskID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_GetRecognitionResultReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var taskID: String = String()

  var tagX: Double = 0

  var tagY: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_SuggestedTag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var foodID: Int32 = 0

  var foodName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_GetRecognitionResultResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tagID: Int32 = 0

  var suggestedTags: [Apisvr_SuggestedTag] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_SearchReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keywords: String = String()

  var category: Apisvr_Category = .unknownCategoryType

  var offset: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_SearchItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var searchItemID: Int32 = 0

  var sampleImageURL: String = String()

  var searchItemName: String = String()

  var searchItemUnit: String = String()

  var energy: Double = 0

  var searchItemWeight: Double = 0

  var searchItemType: Apisvr_Category = .unknownCategoryType

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Apisvr_SearchResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var searchItems: [Apisvr_SearchItem] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "apisvr"

extension Apisvr_InputType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_INPUT_TYPE"),
    1: .same(proto: "RECOMMENDATION"),
    2: .same(proto: "CAMERA"),
    3: .same(proto: "ALBUM"),
    4: .same(proto: "TEXT"),
  ]
}

extension Apisvr_MealType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_MEAL_TYPE"),
    1: .same(proto: "BREAKFAST"),
    2: .same(proto: "LUNCH"),
    3: .same(proto: "DINNER"),
  ]
}

extension Apisvr_Category: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_CATEGORY_TYPE"),
    1: .same(proto: "RECIPE"),
    2: .same(proto: "FAVORITE"),
    3: .same(proto: "RESTAURANT"),
    4: .same(proto: "INGREDIENT"),
  ]
}

extension Apisvr_Calendar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Calendar"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "months"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.year)
      case 2: try decoder.decodeRepeatedInt32Field(value: &self.months)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.year != 0 {
      try visitor.visitSingularInt32Field(value: self.year, fieldNumber: 1)
    }
    if !self.months.isEmpty {
      try visitor.visitPackedInt32Field(value: self.months, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_Calendar, rhs: Apisvr_Calendar) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.months != rhs.months {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_GetMealLogCalendarReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMealLogCalendarReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "calendar"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.calendar)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.calendar.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.calendar, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_GetMealLogCalendarReq, rhs: Apisvr_GetMealLogCalendarReq) -> Bool {
    if lhs.calendar != rhs.calendar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_MealLogCalendarItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MealLogCalendarItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .standard(proto: "img_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.date)
      case 2: try decoder.decodeSingularStringField(value: &self.imgURL)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 1)
    }
    if !self.imgURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imgURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_MealLogCalendarItem, rhs: Apisvr_MealLogCalendarItem) -> Bool {
    if lhs.date != rhs.date {return false}
    if lhs.imgURL != rhs.imgURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_GetMealLogCalendarResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMealLogCalendarResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "calendar_items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.calendarItems)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.calendarItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.calendarItems, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_GetMealLogCalendarResp, rhs: Apisvr_GetMealLogCalendarResp) -> Bool {
    if lhs.calendarItems != rhs.calendarItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_GetFoodDiaryReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetFoodDiaryReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.date)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_GetFoodDiaryReq, rhs: Apisvr_GetFoodDiaryReq) -> Bool {
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_FoodDiaryNutrient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FoodDiaryNutrient"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "energy_intake"),
    2: .standard(proto: "fat_intake"),
    3: .standard(proto: "protein_intake"),
    4: .standard(proto: "carbohydrate_intake"),
    5: .standard(proto: "energy_recommend"),
    6: .standard(proto: "fat_recommend"),
    7: .standard(proto: "protein_recommend"),
    8: .standard(proto: "carbohydrate_recommend"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.energyIntake)
      case 2: try decoder.decodeSingularDoubleField(value: &self.fatIntake)
      case 3: try decoder.decodeSingularDoubleField(value: &self.proteinIntake)
      case 4: try decoder.decodeSingularDoubleField(value: &self.carbohydrateIntake)
      case 5: try decoder.decodeSingularDoubleField(value: &self.energyRecommend)
      case 6: try decoder.decodeSingularDoubleField(value: &self.fatRecommend)
      case 7: try decoder.decodeSingularDoubleField(value: &self.proteinRecommend)
      case 8: try decoder.decodeSingularDoubleField(value: &self.carbohydrateRecommend)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.energyIntake != 0 {
      try visitor.visitSingularDoubleField(value: self.energyIntake, fieldNumber: 1)
    }
    if self.fatIntake != 0 {
      try visitor.visitSingularDoubleField(value: self.fatIntake, fieldNumber: 2)
    }
    if self.proteinIntake != 0 {
      try visitor.visitSingularDoubleField(value: self.proteinIntake, fieldNumber: 3)
    }
    if self.carbohydrateIntake != 0 {
      try visitor.visitSingularDoubleField(value: self.carbohydrateIntake, fieldNumber: 4)
    }
    if self.energyRecommend != 0 {
      try visitor.visitSingularDoubleField(value: self.energyRecommend, fieldNumber: 5)
    }
    if self.fatRecommend != 0 {
      try visitor.visitSingularDoubleField(value: self.fatRecommend, fieldNumber: 6)
    }
    if self.proteinRecommend != 0 {
      try visitor.visitSingularDoubleField(value: self.proteinRecommend, fieldNumber: 7)
    }
    if self.carbohydrateRecommend != 0 {
      try visitor.visitSingularDoubleField(value: self.carbohydrateRecommend, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_FoodDiaryNutrient, rhs: Apisvr_FoodDiaryNutrient) -> Bool {
    if lhs.energyIntake != rhs.energyIntake {return false}
    if lhs.fatIntake != rhs.fatIntake {return false}
    if lhs.proteinIntake != rhs.proteinIntake {return false}
    if lhs.carbohydrateIntake != rhs.carbohydrateIntake {return false}
    if lhs.energyRecommend != rhs.energyRecommend {return false}
    if lhs.fatRecommend != rhs.fatRecommend {return false}
    if lhs.proteinRecommend != rhs.proteinRecommend {return false}
    if lhs.carbohydrateRecommend != rhs.carbohydrateRecommend {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_NutrientByMeal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NutrientByMeal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "breakfast_energy"),
    2: .standard(proto: "lunch_energy"),
    3: .standard(proto: "dinner_energy"),
    4: .standard(proto: "breakfast_percentage"),
    5: .standard(proto: "lunch_percentage"),
    6: .standard(proto: "dinner_percentage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.breakfastEnergy)
      case 2: try decoder.decodeSingularDoubleField(value: &self.lunchEnergy)
      case 3: try decoder.decodeSingularDoubleField(value: &self.dinnerEnergy)
      case 4: try decoder.decodeSingularDoubleField(value: &self.breakfastPercentage)
      case 5: try decoder.decodeSingularDoubleField(value: &self.lunchPercentage)
      case 6: try decoder.decodeSingularDoubleField(value: &self.dinnerPercentage)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.breakfastEnergy != 0 {
      try visitor.visitSingularDoubleField(value: self.breakfastEnergy, fieldNumber: 1)
    }
    if self.lunchEnergy != 0 {
      try visitor.visitSingularDoubleField(value: self.lunchEnergy, fieldNumber: 2)
    }
    if self.dinnerEnergy != 0 {
      try visitor.visitSingularDoubleField(value: self.dinnerEnergy, fieldNumber: 3)
    }
    if self.breakfastPercentage != 0 {
      try visitor.visitSingularDoubleField(value: self.breakfastPercentage, fieldNumber: 4)
    }
    if self.lunchPercentage != 0 {
      try visitor.visitSingularDoubleField(value: self.lunchPercentage, fieldNumber: 5)
    }
    if self.dinnerPercentage != 0 {
      try visitor.visitSingularDoubleField(value: self.dinnerPercentage, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_NutrientByMeal, rhs: Apisvr_NutrientByMeal) -> Bool {
    if lhs.breakfastEnergy != rhs.breakfastEnergy {return false}
    if lhs.lunchEnergy != rhs.lunchEnergy {return false}
    if lhs.dinnerEnergy != rhs.dinnerEnergy {return false}
    if lhs.breakfastPercentage != rhs.breakfastPercentage {return false}
    if lhs.lunchPercentage != rhs.lunchPercentage {return false}
    if lhs.dinnerPercentage != rhs.dinnerPercentage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_FoodDiaryFoodLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FoodDiaryFoodLog"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "food_id"),
    2: .standard(proto: "food_name"),
    3: .same(proto: "amount"),
    4: .same(proto: "unit"),
    5: .same(proto: "energy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.foodID)
      case 2: try decoder.decodeSingularStringField(value: &self.foodName)
      case 3: try decoder.decodeSingularDoubleField(value: &self.amount)
      case 4: try decoder.decodeSingularStringField(value: &self.unit)
      case 5: try decoder.decodeSingularDoubleField(value: &self.energy)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.foodID != 0 {
      try visitor.visitSingularInt32Field(value: self.foodID, fieldNumber: 1)
    }
    if !self.foodName.isEmpty {
      try visitor.visitSingularStringField(value: self.foodName, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularDoubleField(value: self.amount, fieldNumber: 3)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 4)
    }
    if self.energy != 0 {
      try visitor.visitSingularDoubleField(value: self.energy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_FoodDiaryFoodLog, rhs: Apisvr_FoodDiaryFoodLog) -> Bool {
    if lhs.foodID != rhs.foodID {return false}
    if lhs.foodName != rhs.foodName {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.energy != rhs.energy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_FoodDiaryMealLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FoodDiaryMealLog"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "meal_log_id"),
    2: .standard(proto: "img_url"),
    3: .standard(proto: "food_log"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.mealLogID)
      case 2: try decoder.decodeSingularStringField(value: &self.imgURL)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.foodLog)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mealLogID != 0 {
      try visitor.visitSingularInt32Field(value: self.mealLogID, fieldNumber: 1)
    }
    if !self.imgURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imgURL, fieldNumber: 2)
    }
    if !self.foodLog.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.foodLog, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_FoodDiaryMealLog, rhs: Apisvr_FoodDiaryMealLog) -> Bool {
    if lhs.mealLogID != rhs.mealLogID {return false}
    if lhs.imgURL != rhs.imgURL {return false}
    if lhs.foodLog != rhs.foodLog {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_MealLogByType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MealLogByType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "meal_type"),
    2: .standard(proto: "meal_log_by_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.mealType)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.mealLogByType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mealType != .unknownMealType {
      try visitor.visitSingularEnumField(value: self.mealType, fieldNumber: 1)
    }
    if !self.mealLogByType.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mealLogByType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_MealLogByType, rhs: Apisvr_MealLogByType) -> Bool {
    if lhs.mealType != rhs.mealType {return false}
    if lhs.mealLogByType != rhs.mealLogByType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_GetFoodDiaryResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetFoodDiaryResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nutrient"),
    2: .standard(proto: "nutrient_by_meal"),
    3: .same(proto: "mealLogs"),
  ]

  fileprivate class _StorageClass {
    var _nutrient: Apisvr_FoodDiaryNutrient? = nil
    var _nutrientByMeal: Apisvr_NutrientByMeal? = nil
    var _mealLogs: [Apisvr_MealLogByType] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _nutrient = source._nutrient
      _nutrientByMeal = source._nutrientByMeal
      _mealLogs = source._mealLogs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._nutrient)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._nutrientByMeal)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._mealLogs)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._nutrient {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._nutrientByMeal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._mealLogs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mealLogs, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_GetFoodDiaryResp, rhs: Apisvr_GetFoodDiaryResp) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._nutrient != rhs_storage._nutrient {return false}
        if _storage._nutrientByMeal != rhs_storage._nutrientByMeal {return false}
        if _storage._mealLogs != rhs_storage._mealLogs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_GetMealLogReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMealLogReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "meal_log_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.mealLogID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mealLogID != 0 {
      try visitor.visitSingularInt32Field(value: self.mealLogID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_GetMealLogReq, rhs: Apisvr_GetMealLogReq) -> Bool {
    if lhs.mealLogID != rhs.mealLogID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_UnitOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnitOption"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unit_id"),
    2: .same(proto: "name"),
    3: .same(proto: "weight"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.unitID)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularDoubleField(value: &self.weight)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unitID != 0 {
      try visitor.visitSingularInt32Field(value: self.unitID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.weight != 0 {
      try visitor.visitSingularDoubleField(value: self.weight, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_UnitOption, rhs: Apisvr_UnitOption) -> Bool {
    if lhs.unitID != rhs.unitID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_FoodLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FoodLog"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "food_id"),
    2: .standard(proto: "food_name"),
    3: .same(proto: "energy"),
    4: .same(proto: "fat"),
    5: .same(proto: "protein"),
    6: .same(proto: "carbohydrate"),
    7: .same(proto: "amount"),
    8: .standard(proto: "selected_unit_id"),
    9: .standard(proto: "unit_option"),
    10: .same(proto: "ingredients"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.foodID)
      case 2: try decoder.decodeSingularStringField(value: &self.foodName)
      case 3: try decoder.decodeSingularDoubleField(value: &self.energy)
      case 4: try decoder.decodeSingularDoubleField(value: &self.fat)
      case 5: try decoder.decodeSingularDoubleField(value: &self.protein)
      case 6: try decoder.decodeSingularDoubleField(value: &self.carbohydrate)
      case 7: try decoder.decodeSingularDoubleField(value: &self.amount)
      case 8: try decoder.decodeSingularInt32Field(value: &self.selectedUnitID)
      case 9: try decoder.decodeRepeatedMessageField(value: &self.unitOption)
      case 10: try decoder.decodeRepeatedMessageField(value: &self.ingredients)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.foodID != 0 {
      try visitor.visitSingularInt32Field(value: self.foodID, fieldNumber: 1)
    }
    if !self.foodName.isEmpty {
      try visitor.visitSingularStringField(value: self.foodName, fieldNumber: 2)
    }
    if self.energy != 0 {
      try visitor.visitSingularDoubleField(value: self.energy, fieldNumber: 3)
    }
    if self.fat != 0 {
      try visitor.visitSingularDoubleField(value: self.fat, fieldNumber: 4)
    }
    if self.protein != 0 {
      try visitor.visitSingularDoubleField(value: self.protein, fieldNumber: 5)
    }
    if self.carbohydrate != 0 {
      try visitor.visitSingularDoubleField(value: self.carbohydrate, fieldNumber: 6)
    }
    if self.amount != 0 {
      try visitor.visitSingularDoubleField(value: self.amount, fieldNumber: 7)
    }
    if self.selectedUnitID != 0 {
      try visitor.visitSingularInt32Field(value: self.selectedUnitID, fieldNumber: 8)
    }
    if !self.unitOption.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.unitOption, fieldNumber: 9)
    }
    if !self.ingredients.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ingredients, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_FoodLog, rhs: Apisvr_FoodLog) -> Bool {
    if lhs.foodID != rhs.foodID {return false}
    if lhs.foodName != rhs.foodName {return false}
    if lhs.energy != rhs.energy {return false}
    if lhs.fat != rhs.fat {return false}
    if lhs.protein != rhs.protein {return false}
    if lhs.carbohydrate != rhs.carbohydrate {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.selectedUnitID != rhs.selectedUnitID {return false}
    if lhs.unitOption != rhs.unitOption {return false}
    if lhs.ingredients != rhs.ingredients {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_GetMealLogResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMealLogResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "img_url"),
    2: .standard(proto: "food_logs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.imgURL)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.foodLogs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.imgURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imgURL, fieldNumber: 1)
    }
    if !self.foodLogs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.foodLogs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_GetMealLogResp, rhs: Apisvr_GetMealLogResp) -> Bool {
    if lhs.imgURL != rhs.imgURL {return false}
    if lhs.foodLogs != rhs.foodLogs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_FoodTag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FoodTag"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "food_id"),
    2: .standard(proto: "tag_x"),
    3: .standard(proto: "tag_y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.foodID)
      case 2: try decoder.decodeSingularDoubleField(value: &self.tagX)
      case 3: try decoder.decodeSingularDoubleField(value: &self.tagY)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.foodID != 0 {
      try visitor.visitSingularInt32Field(value: self.foodID, fieldNumber: 1)
    }
    if self.tagX != 0 {
      try visitor.visitSingularDoubleField(value: self.tagX, fieldNumber: 2)
    }
    if self.tagY != 0 {
      try visitor.visitSingularDoubleField(value: self.tagY, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_FoodTag, rhs: Apisvr_FoodTag) -> Bool {
    if lhs.foodID != rhs.foodID {return false}
    if lhs.tagX != rhs.tagX {return false}
    if lhs.tagY != rhs.tagY {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_GetFoodLogDetailReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetFoodLogDetailReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "food_tags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.foodTags)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.foodTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.foodTags, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_GetFoodLogDetailReq, rhs: Apisvr_GetFoodLogDetailReq) -> Bool {
    if lhs.foodTags != rhs.foodTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_GetFoodLogDetailResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetFoodLogDetailResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "food_logs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.foodLogs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.foodLogs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.foodLogs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_GetFoodLogDetailResp, rhs: Apisvr_GetFoodLogDetailResp) -> Bool {
    if lhs.foodLogs != rhs.foodLogs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_FoodLogInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FoodLogInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "food_id"),
    2: .same(proto: "amount"),
    3: .standard(proto: "selected_unit_id"),
    4: .standard(proto: "tag_x"),
    5: .standard(proto: "tag_y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.foodID)
      case 2: try decoder.decodeSingularDoubleField(value: &self.amount)
      case 3: try decoder.decodeSingularInt32Field(value: &self.selectedUnitID)
      case 4: try decoder.decodeSingularDoubleField(value: &self.tagX)
      case 5: try decoder.decodeSingularDoubleField(value: &self.tagY)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.foodID != 0 {
      try visitor.visitSingularInt32Field(value: self.foodID, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularDoubleField(value: self.amount, fieldNumber: 2)
    }
    if self.selectedUnitID != 0 {
      try visitor.visitSingularInt32Field(value: self.selectedUnitID, fieldNumber: 3)
    }
    if self.tagX != 0 {
      try visitor.visitSingularDoubleField(value: self.tagX, fieldNumber: 4)
    }
    if self.tagY != 0 {
      try visitor.visitSingularDoubleField(value: self.tagY, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_FoodLogInfo, rhs: Apisvr_FoodLogInfo) -> Bool {
    if lhs.foodID != rhs.foodID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.selectedUnitID != rhs.selectedUnitID {return false}
    if lhs.tagX != rhs.tagX {return false}
    if lhs.tagY != rhs.tagY {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_CreateMealLogReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateMealLogReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "img_url"),
    2: .same(proto: "date"),
    3: .standard(proto: "input_type"),
    4: .standard(proto: "meal_type"),
    5: .standard(proto: "food_logs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.imgURL)
      case 2: try decoder.decodeSingularInt64Field(value: &self.date)
      case 3: try decoder.decodeSingularEnumField(value: &self.inputType)
      case 4: try decoder.decodeSingularEnumField(value: &self.mealType)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.foodLogs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.imgURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imgURL, fieldNumber: 1)
    }
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 2)
    }
    if self.inputType != .unknownInputType {
      try visitor.visitSingularEnumField(value: self.inputType, fieldNumber: 3)
    }
    if self.mealType != .unknownMealType {
      try visitor.visitSingularEnumField(value: self.mealType, fieldNumber: 4)
    }
    if !self.foodLogs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.foodLogs, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_CreateMealLogReq, rhs: Apisvr_CreateMealLogReq) -> Bool {
    if lhs.imgURL != rhs.imgURL {return false}
    if lhs.date != rhs.date {return false}
    if lhs.inputType != rhs.inputType {return false}
    if lhs.mealType != rhs.mealType {return false}
    if lhs.foodLogs != rhs.foodLogs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_CreateMealLogResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateMealLogResp"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_CreateMealLogResp, rhs: Apisvr_CreateMealLogResp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_UpdateMealLogReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateMealLogReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "meal_log_id"),
    2: .standard(proto: "food_logs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.mealLogID)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.foodLogs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mealLogID != 0 {
      try visitor.visitSingularInt32Field(value: self.mealLogID, fieldNumber: 1)
    }
    if !self.foodLogs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.foodLogs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_UpdateMealLogReq, rhs: Apisvr_UpdateMealLogReq) -> Bool {
    if lhs.mealLogID != rhs.mealLogID {return false}
    if lhs.foodLogs != rhs.foodLogs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_UpdateMealLogResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateMealLogResp"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_UpdateMealLogResp, rhs: Apisvr_UpdateMealLogResp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_DeleteMealLogReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteMealLogReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "meal_log_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.mealLogID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mealLogID != 0 {
      try visitor.visitSingularInt32Field(value: self.mealLogID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_DeleteMealLogReq, rhs: Apisvr_DeleteMealLogReq) -> Bool {
    if lhs.mealLogID != rhs.mealLogID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_DeleteMealLogResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteMealLogResp"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_DeleteMealLogResp, rhs: Apisvr_DeleteMealLogResp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_RecognitionReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecognitionReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "img_url"),
    2: .standard(proto: "meal_date"),
    3: .standard(proto: "meal_type"),
    4: .same(proto: "lat"),
    5: .same(proto: "lng"),
    6: .standard(proto: "img_upload_speed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.imgURL)
      case 2: try decoder.decodeSingularInt64Field(value: &self.mealDate)
      case 3: try decoder.decodeSingularEnumField(value: &self.mealType)
      case 4: try decoder.decodeSingularDoubleField(value: &self.lat)
      case 5: try decoder.decodeSingularDoubleField(value: &self.lng)
      case 6: try decoder.decodeSingularInt32Field(value: &self.imgUploadSpeed)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.imgURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imgURL, fieldNumber: 1)
    }
    if self.mealDate != 0 {
      try visitor.visitSingularInt64Field(value: self.mealDate, fieldNumber: 2)
    }
    if self.mealType != .unknownMealType {
      try visitor.visitSingularEnumField(value: self.mealType, fieldNumber: 3)
    }
    if self.lat != 0 {
      try visitor.visitSingularDoubleField(value: self.lat, fieldNumber: 4)
    }
    if self.lng != 0 {
      try visitor.visitSingularDoubleField(value: self.lng, fieldNumber: 5)
    }
    if self.imgUploadSpeed != 0 {
      try visitor.visitSingularInt32Field(value: self.imgUploadSpeed, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_RecognitionReq, rhs: Apisvr_RecognitionReq) -> Bool {
    if lhs.imgURL != rhs.imgURL {return false}
    if lhs.mealDate != rhs.mealDate {return false}
    if lhs.mealType != rhs.mealType {return false}
    if lhs.lat != rhs.lat {return false}
    if lhs.lng != rhs.lng {return false}
    if lhs.imgUploadSpeed != rhs.imgUploadSpeed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_RecognitionResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecognitionResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.taskID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_RecognitionResp, rhs: Apisvr_RecognitionResp) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_GetRecognitionResultReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRecognitionResultReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_id"),
    2: .standard(proto: "tag_x"),
    3: .standard(proto: "tag_y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.taskID)
      case 2: try decoder.decodeSingularDoubleField(value: &self.tagX)
      case 3: try decoder.decodeSingularDoubleField(value: &self.tagY)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 1)
    }
    if self.tagX != 0 {
      try visitor.visitSingularDoubleField(value: self.tagX, fieldNumber: 2)
    }
    if self.tagY != 0 {
      try visitor.visitSingularDoubleField(value: self.tagY, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_GetRecognitionResultReq, rhs: Apisvr_GetRecognitionResultReq) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.tagX != rhs.tagX {return false}
    if lhs.tagY != rhs.tagY {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_SuggestedTag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SuggestedTag"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "food_id"),
    2: .standard(proto: "food_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.foodID)
      case 2: try decoder.decodeSingularStringField(value: &self.foodName)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.foodID != 0 {
      try visitor.visitSingularInt32Field(value: self.foodID, fieldNumber: 1)
    }
    if !self.foodName.isEmpty {
      try visitor.visitSingularStringField(value: self.foodName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_SuggestedTag, rhs: Apisvr_SuggestedTag) -> Bool {
    if lhs.foodID != rhs.foodID {return false}
    if lhs.foodName != rhs.foodName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_GetRecognitionResultResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRecognitionResultResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tag_id"),
    2: .standard(proto: "suggested_tags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.tagID)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.suggestedTags)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tagID != 0 {
      try visitor.visitSingularInt32Field(value: self.tagID, fieldNumber: 1)
    }
    if !self.suggestedTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.suggestedTags, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_GetRecognitionResultResp, rhs: Apisvr_GetRecognitionResultResp) -> Bool {
    if lhs.tagID != rhs.tagID {return false}
    if lhs.suggestedTags != rhs.suggestedTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_SearchReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SearchReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keywords"),
    2: .same(proto: "category"),
    3: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.keywords)
      case 2: try decoder.decodeSingularEnumField(value: &self.category)
      case 3: try decoder.decodeSingularInt32Field(value: &self.offset)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keywords.isEmpty {
      try visitor.visitSingularStringField(value: self.keywords, fieldNumber: 1)
    }
    if self.category != .unknownCategoryType {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_SearchReq, rhs: Apisvr_SearchReq) -> Bool {
    if lhs.keywords != rhs.keywords {return false}
    if lhs.category != rhs.category {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_SearchItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SearchItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "search_item_id"),
    2: .standard(proto: "sample_image_url"),
    3: .standard(proto: "search_item_name"),
    4: .standard(proto: "search_item_unit"),
    5: .same(proto: "energy"),
    6: .standard(proto: "search_item_weight"),
    7: .standard(proto: "search_item_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.searchItemID)
      case 2: try decoder.decodeSingularStringField(value: &self.sampleImageURL)
      case 3: try decoder.decodeSingularStringField(value: &self.searchItemName)
      case 4: try decoder.decodeSingularStringField(value: &self.searchItemUnit)
      case 5: try decoder.decodeSingularDoubleField(value: &self.energy)
      case 6: try decoder.decodeSingularDoubleField(value: &self.searchItemWeight)
      case 7: try decoder.decodeSingularEnumField(value: &self.searchItemType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.searchItemID != 0 {
      try visitor.visitSingularInt32Field(value: self.searchItemID, fieldNumber: 1)
    }
    if !self.sampleImageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.sampleImageURL, fieldNumber: 2)
    }
    if !self.searchItemName.isEmpty {
      try visitor.visitSingularStringField(value: self.searchItemName, fieldNumber: 3)
    }
    if !self.searchItemUnit.isEmpty {
      try visitor.visitSingularStringField(value: self.searchItemUnit, fieldNumber: 4)
    }
    if self.energy != 0 {
      try visitor.visitSingularDoubleField(value: self.energy, fieldNumber: 5)
    }
    if self.searchItemWeight != 0 {
      try visitor.visitSingularDoubleField(value: self.searchItemWeight, fieldNumber: 6)
    }
    if self.searchItemType != .unknownCategoryType {
      try visitor.visitSingularEnumField(value: self.searchItemType, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_SearchItem, rhs: Apisvr_SearchItem) -> Bool {
    if lhs.searchItemID != rhs.searchItemID {return false}
    if lhs.sampleImageURL != rhs.sampleImageURL {return false}
    if lhs.searchItemName != rhs.searchItemName {return false}
    if lhs.searchItemUnit != rhs.searchItemUnit {return false}
    if lhs.energy != rhs.energy {return false}
    if lhs.searchItemWeight != rhs.searchItemWeight {return false}
    if lhs.searchItemType != rhs.searchItemType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Apisvr_SearchResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SearchResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "search_items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.searchItems)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.searchItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.searchItems, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Apisvr_SearchResp, rhs: Apisvr_SearchResp) -> Bool {
    if lhs.searchItems != rhs.searchItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
